#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Script to resample a tractogram to a set number of streamlines.

Default behavior:
- If the number of requested streamlines is lower than the streamline count:
DOWNSAMPLE
- If the number of requested streamlines is higher than the streamline count:
UPSAMPLE  (to prevent upsampling when not desired, use --never_upsample).

Upsampling:
    Works by generating new streamlines, either by adding gaussian noise to
    existing streamlines (with value --point_wise_std).

    Includes smoothing (of value --gaussian) to compensate for the noisiness of
    new streamlines generated by the process. It is also possible to restrict
    generated streamlines to a radius around the initial ones (--tube_radius).

    Can be useful to build training sets for machine learning algorithms, to
    upsample under-represented bundles or downsample over-represented bundles.

Downsampling:
    Works by selecting a subset of streamlines.

    Includes the possibility of choosing randomly *per Quickbundle cluster* to
    ensure that all clusters are represented in the final tractogram.

Example usage:
$ scil_tractogram_resample.py input.trk 1000 output.trk \
--point_wise_std 0.5 --gaussian 5 --keep_invalid_streamlines
$ scil_viz_bundle.py output.trk --local_coloring --width=0.1
"""

import argparse
import logging

from dipy.io.streamline import save_tractogram

from scilpy.io.streamlines import load_tractogram_with_reference
from scilpy.io.utils import (add_overwrite_arg, add_reference_arg,
                             add_verbose_arg,
                             assert_inputs_exist,
                             assert_outputs_exist, ranged_type,
                             add_compression_arg)
from scilpy.tractograms.tractogram_operations import (
    split_sft_randomly,
    split_sft_randomly_per_cluster,
    upsample_tractogram)


def _build_arg_parser():
    p = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter,
                                description=__doc__)

    p.add_argument('in_tractogram',
                   help='Input tractography file.')
    p.add_argument('nb_streamlines', type=int,
                   help='Number of streamlines to resample the tractogram to.')
    p.add_argument('out_tractogram',
                   help='Output tractography file.')

    p.add_argument('--never_upsample', action='store_true',
                   help='Make sure to never upsample a tractogram.\n'
                        'Useful when downsampling a batch of files using '
                        'bash.')

    # For upsampling:
    up_group = p.add_argument_group('Upsampling params')
    up_group.add_argument('--point_wise_std', type=ranged_type(float, 0, None),
                          default=1,
                          help='Noise to add to existing streamlines '
                               'points to generate new ones [%(default)s].')
    up_group.add_argument('--tube_radius', type=ranged_type(float, 0, None),
                          default=1,
                          help='Maximum distance to generate streamlines '
                               'around the original ones [%(default)s].')
    up_group.add_argument('--gaussian', metavar='SIGMA',
                          type=ranged_type(float, 0, None, min_excluded=True),
                          help='Sigma for smoothing. Use the value of '
                               'surrounding X,Y,Z points on the '
                               'streamline to blur the streamlines.\n'
                               'A good sigma choice would be around 5.\n'
                               'Default: no smoothing.')
    up_group.add_argument('--keep_invalid_streamlines',
                          action='store_true',
                          help='Keep invalid newly generated streamlines '
                               'that may go out of the \nbounding box.')
    add_compression_arg(up_group)

    # For downsampling:
    downsampling_group = p.add_argument_group('Downsampling params')
    downsampling_group.add_argument(
        '--downsample_per_cluster', action='store_true',
        help='If set, downsampling will be done per cluster (computed with \n'
             'Quickbundles) to ensure that at least some streamlines are \n'
             'kept per bundle. Else, random downsampling is performed '
             '(default).')
    downsampling_group.add_argument(
        '--qbx_thresholds', nargs='+', type=float, default=[40, 30, 20],
        help="If you chose option '--downsample_per_cluster', you may set \n"
             "the QBx threshold value(s) here. Default: %(default)s")

    # General
    p.add_argument('--seed', default=None, type=int,
                   help='Use a specific random seed for the resampling.')

    add_reference_arg(p)
    add_verbose_arg(p)
    add_overwrite_arg(p)

    return p


def main():
    parser = _build_arg_parser()
    args = parser.parse_args()
    logging.getLogger().setLevel(logging.getLevelName(args.verbose))

    # Verifications
    if args.point_wise_std <= 0:
        parser.error('argument --point_wise_std: must be > 0')
    if args.tube_radius <= 0:
        parser.error('argument --tube_radius: must be > 0')

    assert_inputs_exist(parser, args.in_tractogram, args.reference)
    assert_outputs_exist(parser, args, args.out_tractogram)

    # Loading
    logging.info("Loading sft.")
    sft = load_tractogram_with_reference(parser, args, args.in_tractogram)
    original_number = len(sft.streamlines)

    # Processing
    if args.nb_streamlines > original_number:
        if args.never_upsample:
            logging.info(
                "Number of streamlines is higher than in the original "
                "tractogram. Cannot downsample. To upsample, remove option "
                "--never_upsample. Out_tractogram will be a copy of "
                "in_tractogram.")
        else:
            # Check is done here because it is not required if downsampling
            if not args.point_wise_std and not args.tube_radius:
                parser.error("one of the arguments --point_wise_std " +
                             "--tube_radius is required")
            sft = upsample_tractogram(sft, args.nb_streamlines,
                                      args.point_wise_std, args.tube_radius,
                                      args.gaussian, args.compress_th,
                                      args.seed)
    elif args.nb_streamlines < original_number:
        if args.downsample_per_cluster:
            # output contains rejected streamlines, we don't use them.
            sft, _ = split_sft_randomly_per_cluster(
                sft, [args.nb_streamlines], args.seed, args.qbx_thresholds)
            logging.info("Kept {} out of {} expected streamlines."
                         .format(len(sft), args.nb_streamlines))
        else:
            # output is a list of two: kept and rejected.
            sft = split_sft_randomly(sft, args.nb_streamlines, args.seed)[0]
    else:
        logging.info("Number of streamlines in in_tractogram is already "
                     "correct! Out_tractogram will be a copy of "
                     "in_tractogram.")

    if not args.keep_invalid_streamlines:
        sft.remove_invalid_streamlines()
        logging.info("After removing invalid streamlines, the number of "
                     "remaining streamlines is: {}".format(len(sft)))
    save_tractogram(sft, args.out_tractogram,
                    bbox_valid_check=not args.keep_invalid_streamlines)


if __name__ == "__main__":
    main()
